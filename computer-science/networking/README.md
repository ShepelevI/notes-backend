#### Битовые операции

Побитовые операторы проводят операции непосредственно на битах числа.

- Побитовое **И / AND** (разряд результата равен 1 только тогда, когда оба соответствующих бита операндов равны 1):

        
        println(0b111_000 /* 56 */ & 0b011_110 /* 30 */ == 0b011_000 /* 24 */)

- Побитовое **ИЛИ / OR** (разряд результата равен 0 только тогда, когда оба соответствующих бита в равны 0):
    
      
        println(0b111_000 /* 56 */ | 0b011_110 /* 30 */ == 0b111_110 /* 62 */)

- Исключающее **ИЛИ / XOR** (разряд результата равен 1 только тогда, когда только один бит равен 1):
    

        println(0b111_000 /* 56 */ ^ 0b011_110 /* 30 */ == 0b100_110 /* 38 */)

- Сброс бита **AND NOT**:


        println(0b111_001 /* 57 */ &^ 0b011_110 /* 30 */ == 0b100_001 /* 33 */)

- Сдвиг бита **влево**:


        println(0b000_001 /* 1 */ << 3 == 0b001_000 /* 8 */)

- Сдвиг бита **вправо**:


        println(0b000_111 /* 7 */ >> 1 == 0b000_011 /* 3 */)

Пример использования простой битовой маски:

        type Bits uint8

        const (
            F0 Bits = 1 << iota // 0b00_000_001 == 1
            F1                  // 0b00_000_010 == 2
            F2                  // 0b00_000_100 == 4
        )

        func Set(b, flag Bits) Bits    { return b | flag }
        func Clear(b, flag Bits) Bits  { return b &^ flag }
        func Toggle(b, flag Bits) Bits { return b ^ flag }
        func Has(b, flag Bits) bool    { return b&flag != 0 }

        func main() {
            var b Bits

            b = Set(b, F0)
            b = Toggle(b, F2)

            for i, flag := range [...]Bits{F0, F1, F2} {
                println(i, Has(b, flag))
            }
            // 0 true
            // 1 false
            // 2 true
        }