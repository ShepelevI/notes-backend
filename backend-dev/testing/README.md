#### Testing (тестирование)

Для unit-тестирования (модульного) используется команда `go test`, запускает все функции,
начинающиеся с префикса `Test` в файлах, имеющие в своем имени **постфикс** `_test.go`.

Важно писать сам код так, чтоб его можно было протестировать
(не забывать про **инвертирование зависимостей** и использовать интерфейсы там, где они уместны).

#### TDT, Table-driven tests (табличное тестирование)

Более предпочтительный вариантом для тестирования множества однотипных кейсов перед описанием
"один кейс — один тест", позволяют отделить часть входных данных и ожидаемых данных от всех этапов инициализации
и tear-down (не знаю как это будет по-русски).

**Пример**:

        package main

        func Sum(a, b int) int { return a + b }
<br>

        package main

        import "testing"

        func TestSum(t *testing.T) {
            for name, tt := range map[string]struct { // ключ мапы - имя теста
                giveOne, giveSecond int
                wantResult          int
        }{
                "1 + 1 = 2": {
                    giveOne: 1, giveSecond: 1, wantResult: 2,
                },
                "140 + 6 = 146": {
                    giveOne: 140, giveSecond: 6, wantResult: 146,
                },
        } {
                t.Run(name, func(t *testing.T) {
                        // setup here

                    if res := Sum(tt.giveOne, tt.giveSecond); res != tt.wantResult {
                        t.Errorf("Unexpected result. Want %d, got %d", tt.wantResult, res)
                    }

                    // teardown here
                })
            }
        }

#### Имя пакета с тестами

Если имя пакета в файле с тестами (`foo_test.go`) указывать с постфиксом `_test`
(например — имя пакета, для которого пишутся тесты `foo`, а имя пакета указанное в самом файле
с тестами для него — `foo_test`), то в тестах не будет доступа к не экспортируемым свойствам,
структурам и функциям, т. о. тестирование пакета будет происходить "как извне",
не будет соблазна пытаться использовать что-то "приватное", содержащееся в пакете.
В теории, в одной директории не может находиться 2 и более файлов, имена пакетов в которых отличаются,
но `*_test` - исключение.

Такой подход стимулирует тестировать API, а не внутренние механизмы,
т.е. относиться к функциональности как к "черному ящику", что очень правильно.

#### Статические анализаторы (линтеры)

`golangci-lint` - универсальное решение, объединяющее множествов линтеров в "одном флаконе".
Удобен как для запуска локально, так и на CI.

#### Ошибка в бенчмарке

Иногда встречается кейс с написанием бенчмарка, который внутри своего цикла выполняет тестируемую функцию,
результат этого действия никуда не присваивается и не передаётся:

        func BenchmarkWrong(b *testing.B) {
            for i := 0; i < b.N; i++ {
                ourFunc()
            }
        }

Компилятор может принять это во внимание, и будет выполнять её содержимое как **inline-последовательность инструкций**.
После чего, компилятор определит, что вызов тестируемой функции не имеет никаких побочных эффектов (side-effects),
т.е. никак не влияет на среду исполнения. 
После чего вызов тестируемой функции будет просто удалён.
Один из вариантов избежать такого сценария – присваивать результат выполнения функции переменной уровня пакета. 

**Пример**:

        var result uint64

        func BenchmarkCorrect(b *testing.B) {
            var r uint64
            for i := 0; i < b.N; i++ {
                r = ourFunc()
            }
            result = r
        } 

Теперь компилятор не будет знать, есть ли у функции side-effect и бенчмарк будет точен.

#### функциональное тестирование

Для HTTP можно `postman` и его CLI-версию `newman`. 

Ещё как вариант "быстро и просто" — это `hurl`.

Для mock стороннего HTTP API — `jmartin82/mmock` или `lamoda/gonkey`.

#### Профилирование (pprof)

Для профилирования "родными" средствами в поставке с Go имеется пакет `pprof` и одноименная консольная утилита
`go tool pprof`. 

**Причинами** необходимости в профилировании могут стать:

* Длительная работа различных частей программы;
* Высокое потребление памяти;
* Высокое потребление ресурсов процессора.

Профилировщик является **семплирующим** — с какой-то периодичностью прерываем работу программы,
берем стек-трейс, записываем его куда-то, в конце, на основе того, как часто в стек-трейсах встречаются разные функции,
понимаем, какие из них использовали больше ресурсов процессора, какие меньше. 

Работа состоит из двух этапов — сбор статистики по работе сервиса, и её визуализация + анализ. 
Собирать статистику можно добавив вызовы пакета `pprof`, либо запустив HTTP сервер.

**Пример**:

Есть функция, которая выполняется по какой-то причине очень долго.
Обрамим вызовы потенциально-тяжелого кода в `startPprof` и `stopPprof`:

        package main

        import (
            "os"
            "runtime/pprof"
            "time"
        )

        func startPprof() *os.File { // вспомогательная функция начала профилирования
            f, err := os.Create("profile.pprof")
            if err != nil {
                panic(err)
        }

            if err = pprof.StartCPUProfile(f); err != nil {
                panic(err)
        }

                return f
        }

        func stopPprof(f *os.File) { // вспомогательная функция завершения профилирования
            pprof.StopCPUProfile()

            if err := f.Close(); err != nil {
                panic(err)
            }
        }

        func main() { // основания функция
            var (
                slice = make([]int, 0)
                m     = make(map[int]int)
            )

            pprofFile := startPprof() // начинаем профилирование

            // здесь начинается какая-то "тяжелая" работа
            for i := 0; i < 10_000_000; i++ {
                slice = append(slice, i*i)
            }

            for i := 0; i < 10_000_000; i++ {
                m[i] = i * i
            }

            <-time.After(time.Second)
            // здесь она завершается

            stopPprof(pprofFile) // завершаем профилирование
        }

После компиляции и запуска приложения (`go build -o ./main . && ./main`)
в текущей директории появится файл с именем `profile.pprof`, содержащий профиль работы.
"Конвертируем" его в читаемое представление в виде svg изображения с помощью `go tool pprof -svg ./profile.pprof`
(в Linux для этого понадобится пакет `graphviz`) и открываем его (имя файла будет в виде `profile001.svg`):

<img src="https://habrastorage.org/r/w1560/webt/xp/y5/zy/xpy5zy7f3zoixmwzbf8840hbc6o.png" title="pprof_before" width="1000" alt="pprof_before"/>

Смотрим на получившийся граф вызовов. Изучая такой граф, нужно обращать внимание на толщину ребер (стрелок)
и на размер узлов графа (квадратов). На ребрах подписано время — сколько времени данный узел или любой из ниже лежащих
узлов находился в стек-трейсе во время профилирования.

Можем заметить, что `runtime evacuate_fast64` занимает много времени. 
Связано с тем, что из `map` данным приходиться эвакуироваться, т. к. размер `map` сильно растёт.
Исправляем, заодно и слайс, в двух строчках:

        var (
            slice = make([]int, 0, 10_000_000)    // заставляем аллоцировать память в slice
            m     = make(map[int]int, 10_000_000) // и в map заранее
        )

Повторяем все сделанные ранее операции снова, видим другую картину:

<img src="https://habrastorage.org/r/w1560/webt/t0/vp/sq/t0vpsqvhpscvxj95bhf7djge4cg.png" title="pprof_after" width="1000" alt="pprof_after"/>

Теперь картина значительно лучше, следующее место оптимизации (потенциально) - пересмотреть работу с данными,
а именно, нужна ли нам работа с `map` в принципе (может заменить её каким-то `slice`),
если нет, то как можно улучшить (оптимизировать) запись в неё.

#### Работа профилировщика в принципе

`runtime` просит ОС посылать сигнал (`man setitimer`) с определенной периодичностью, назначает на этот сигнал обработчик.
Обработчик берет стек-трейс всех горутин, какую-то дополнительную информацию, записывает ее в буфер и выходит.

**Недостатки**:

* Каждый сигнал — изменение контекста, довольно затратно.
В Go сейчас получается получить порядка **100 в секунду**. Иногда этого мало.

* Для нестандартных сборок, например, с использованием `-buildmode=c-archive` или `-buildmode=c-shared`,
профайлер работать **по умолчанию не будет**, связано с тем, что сигнал `SIGPROF`, который посылает ОС,
придет в основной поток программы, который не контролируется Go.
* Процесс `user space`, которым является программа на Go, не может получить ядерный стек-трейс.
Неоптимальности и проблемы иногда кроются и в ядре.

**Основное преимущество** - `Go runtime` обладает полной информацией о своем внутреннем устройстве.
Внешние средства, например, по умолчанию ничего не знают о горутинах.
Для них существуют только процессы и треды.
