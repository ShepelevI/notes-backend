### `Stack` (стек)

Область оперативной памяти, которая создаётся для каждого потока. 
Работает в порядке `LIFO` (Last In, First Out), т. е. последний добавленный в `stack` кусок памяти будет первым
в очереди на вывод из `stack`. 
Каждый раз, когда функция объявляет новую переменную, она добавляется в `stack`,
а когда эта переменная пропадает из области видимости (например, когда функция заканчивается),
она автоматически удаляется из `stack`.
Когда стековая переменная освобождается, эта область памяти становится доступной для других стековых переменных.

`stack` быстрый, т. к. часто привязан к кэшу процессора.

Размер `stack` ограничен, задаётся при создании потока.

Ему не нужно иметь сборщик мусора (garbage collector),
переменные просто создаются, затем вытесняются, когда функция завершается.

Не нужно запускать сложный процесс освобождения памяти от неиспользуемых переменных.

`stack` принадлежит одной горутине, переменные не нужно синхронизировать в сравнении с теми, что находятся в `heap`,
что также повышает производительность.

### `Heap` (куча) 

Хранилище памяти, также расположенное в ОЗУ, которое допускает динамическое выделение памяти,
и не работает по принципу `stack` - просто склад для переменных. 
Когда выделяем в `heap` участок памяти для хранения переменной, к ней можно обратиться не только в потоке,
но и во всем приложении. 
Так определяются глобальные переменные. 
По завершении приложения все выделенные участки памяти освобождаются.
Размер `heap` задаётся при запуске приложения, но, в отличие от `stack`, он ограничен лишь физически,
что позволяет создавать динамические переменные.

В сравнении с `stack`, `heap` работает медленнее, потому что переменные разбросаны по памяти,
а не сидят на верхушке `stack`. 

Что попадает в `heap`, живёт там пока не придёт `GC` (garbage collector).


**Прямых инструментов для управления местом, где будет выделена память — нет**.

Память под переменную может быть выделена в `heap` или `stack`. Очень приблизительно:

* `stack` содержит последовательность переменных для заданной горутины
(как только функция завершила работу, переменные вытесняются из `stack`);
* `heap` содержит общие (shared) переменные (глобальные и т.п.).

Пример, в нем возвращаем значение:

        func getFooValue() foo {
            var result foo
            // Do something
            return result
        }

`result` создаётся в текущей горутине, эта переменная помещается в `stack`.
Как только функция завершает работу, клиент получает копию этой переменной.
Исходная переменная вытесняется из `stack`.
Эта переменная всё ещё существует в памяти, до тех пор, пока не будет затёрта другой переменной,
но к этой переменной уже нельзя получить доступ.

Пример, с **указателем**:

        func getFooPointer() *foo {
            var result foo
            // Do something
            return &result
        }

`result` также создаётся текущей горутиной, но клиент получает указатель (копию адреса переменной).
Если `result` вытеснена из `stack`, клиент функции не сможет получить доступ к переменной.

В подобном сценарии компилятор Go вынужден переместить переменную `result` туда,
где она может быть доступна (shared) – в `heap`.

Есть **исключение**, пример:

        func main()  {
            p := &foo{}
            f(p)
        }

Т. к. вызываем функцию `f()` в той же горутине, что и функцию `main()`, переменную `p` не нужно перемещать. 
Она находится в `stack` и вложенная функция `f()` будет иметь к ней доступ.

Когда создаём функцию — поведением по умолчанию должно быть использование передачи по значению, а не по указателю.
Указатель должен быть использован только, когда действительно хотим переиспользовать данные.

### Escape analysis

Процесс, который компилятор использует для определения размещения значений, созданных программой.

Компилятор выполняет статический анализ кода, чтобы определить,
может ли значение быть помещено в стековый фрейм для функции, которая его строит, или значение должно "сбежать" в `heap`.
Используется разработчиками для оптимизации кода и аналитики причин возможного замедления.

Команда для запуска escape-анализа: `go build -gcflags="-m"` (так же можно использовать флаги `-N` 
для отключения оптимизаций, `-l` для отключения "инлайнинга").