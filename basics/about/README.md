#### Про Golang

Разработан Google (Роберт Гризмер, Роб Пайк, Кен Томпсон).

Официально представлен в ноябре 2009 года (разработка началась в 2007 году).

**Особенности**:

* Компилируемый, многопоточный;
* Создавался по принципу "что еще можно выкинуть";
* **Императивный** (конкретно описываем необходимые действия для достижения определенного результата);
* Строгая типизация, отказ от иерархии типов;
* Сборка мусора (GC);
* Простые и эффективные средства для распараллеливания вычислений;
* Четкое разделение интерфейса и реализации;
* Наличие системы пакетов и возможность импортировать внешние зависимости (пакеты);
* Богатый тулинг "из коробки" (тесты, бенчмарки, быстрая компиляция, генерация кода и документации);
* **Нет классического ООП**, вместо этого предлагается несколько отдельных подходов:
  * встраивание объектов;
  * интерфейсы как контракты реализаций;
  * пакеты;
  * возможность создания методов к типам;
* Если используем сторонний пакет (например, логгер Zap в проекте, 
и хотим к этому Zap "прикрутить" наши методы, то нужно создать свою структуру, 
внутри в неё встраивать логгер Zap, к этой структуре уже "прикручивать" требуемые методы. 
Просто "навесить сверху" функции на сторонний пакет мы **не можем**.

#### ООП

Методология (подход) программирования, основанная на том,
что программа представляет собой некоторую совокупность объектов-классов,
которые образуют иерархию наследования.

**Ключевые фишки** - минимализация повторяемости кода (**DRY**) и удобство понимания/управления.

**Фундамент ООП** - описание объектов в программировании подобно объектам из реального мира - у них есть свойства,
поведение, они могут взаимодействовать.

**Основные принципы в ООП**:

* **Абстракция** - фокусирование на тех свойствах системы, которые важны в рамках текущей задачи,
менее существенные отбрасываем (абстракция данных и методов);
* **Инкапсуляция** - заключение данных и функциональности в оболочку,
в ее роли - классы - собирают переменные и методы в одном месте, защищают от вмешательства извне;
* **Наследование** - родительские классы лежат в основе других - дочерних,
при этом, дочерние перенимают свойства и поведение своего родителя;
* **Полиморфизм** - возможность использовать одни и те же методы для объектов разных классов.


#### В Golang:

* **Нет классов, объектов, исключений и шаблонов**;
* **Нет иерархии типов**, но есть сами типы (т.е. возможность описывать свои типы/структуры); 
* Структурные типы (с методами) служат тем же целям, что и классы в других языках; 
* **Структура определяет состояние**;
* **Нет наследования**, есть **встраивание** (называемое "анонимным", т.е. имя поля можно не указывать при обращении к 
полям/методам встроенного типа) при этом встраиваются и свойства, и функции:

        import "fmt"

        type Foo struct {
            name    string
            Surname string
        }

        func (f Foo) SayName() string { return f.name }

        type Bar struct {
            Foo
        }

        func main() {
            bar := Bar{Foo{name: "one", Surname: "baz"}}

            fmt.Println(bar.SayName()) // one
            fmt.Println(bar.Surname)   // baz

            bar.name = "two"

            fmt.Println(bar.SayName()) // two
        }

* Есть **интерфейсы** (это типы, которые объявляют наборы методов), подобно интерфейсам в других языках,
они не имеют реализации. Объекты, которые реализуют все методы интерфейса, 
автоматически реализуют интерфейс (так называемый `Duck-typing`);
* **Не существует** наследования или подклассов или ключевого слова `Implements`;
* **Инкапсуляция** представлена возможностью использовать пакеты и видимость полей/методов
для инкапсуляции. Поля и методы, начинающиеся с заглавной буквы, являются публичными,
а с маленькой - приватными:

        package main

        type person struct {
          name string
          age  int
        }

        func (p *person) getName() string {
          return p.name
        }

        func (p *person) setName(name string) {
          p.name = name
        }

        func main() {
          p := &person{name: "John", age: 30}
          fmt.Println(p.getName()) // Выведет "John"
          p.setName("Jane")
          fmt.Println(p.getName()) // Выведет "Jane"
        }

* **Полиморфизм** представлен через интерфейсы (**контракты реализаций**). 
Интерфейс определяет набор методов, которые должны быть реализованы типом. 
Тип, реализующий интерфейс, может быть использован везде, где ожидается интерфейс:

        package main

        type speaker interface {
          speak()
        }

        type dog struct {
          name string
        }

        func (d *dog) speak() {
          fmt.Printf("%s гавкает\n", d.name)
        }

        type cat struct {
          name string
        }

        func (c *cat) speak() {
          fmt.Printf("%s мяукает\n", c.name)
        }

        func main() {
          var s speaker
          s = &dog{name: "Buddy"}
          s.speak() // Выведет "Buddy гавкает"

          s = &cat{name: "Kitty"}
          s.speak() // Выведет "Kitty мяукает"
        }

* **Наследование** представлено **композицией** - встариванием одних структур в другие для расширения функциональности:

        package main

        type animal struct {
          name string
        }

        func (a *animal) speak() {
          fmt.Printf("%s говорит\n", a.name)
        }

        type dog struct {
          animal
          breed string
        }

        func main() {
          d := &dog{animal: animal{name: "Buddy"}, breed: "Labrador"}
          d.speak() // Выведет "Buddy говорит"
        }

* **Абстракция** представлена использованием интерфейсов для определения абстрактных типов и их реализаций.


#### DRY

> Каждая часть знания должна иметь единое, однозначное, авторитетное представление в системе 
 
Сформулирован Энди Хантом и Дэйвом Томасом в их книге «Прагматичный программист».


#### SOLID

* **принцип единственной ответственности**:
модуль должен отвечать за одного и только за одного актора, 
где актор определён как группа, состоящая из одного или нескольких лиц, желающих данного изменения,
требования к каждому модулю, связному набору функций и структур данных 
должны поступать от одного актора;
* **принцип открытости/закрытости**:
модули должны быть открыты для расширения,
но закрыты для модификации, должна быть возможность расширить поведение,
наделить новым функционалом, но при этом исходный код/логика модуля должна быть неизменной;
* **принцип подстановки Барбары Лисков**:
поведение наследующих классов не должно противоречить поведению,
заданному базовым классом, то есть поведение наследующих классов должно быть ожидаемым для кода;
* **принцип разделения интерфейса**:
много тонких интерфейсов лучше, чем один толстый;
* **принцип инверсии зависимостей**:
модули верхних уровней не должны зависеть от модулей нижних уровней,
оба типа уровней должны зависеть от абстракций, абстракции не должны зависеть от деталей,
детали должны зависеть от абстракций: (объявляем интерфейс `speaker` не экспортируемым на нашей, 
принимающей стороне, и используя конструктор `NewFoo` гарантируем, 
что свойство `s` будет проинициализировано верным типом (дополнительно проверяя его на `nil`)):


          import (
              "errors"
              "fmt"
          )

          type speaker interface {
              Speak() string
          }

          type Foo struct {
              s speaker // s *Foo - было бы плохо
          }

          func NewFoo(s speaker) (*Foo, error) {
              if s == nil {
                  return nil, errors.New("speaker is nil")
          }

          return &Foo{s: s}, nil
          }

          func (f Foo) SaySomething() string { return f.s.Speak() }

          func main() {
              var foo, err = NewFoo(someSpeaker)

              if err != nil {
                  panic(err)
          }

          fmt.Println(foo.SaySomething()) // зависит от реализации speaker
          }


#### Дженерики

Дженерики или **обобщения** — средства языка, позволяющие работать с различными типами данных без изменения их описания.

В Go 1.18 завезли дженерики (были и ранее, но не могли их использовать в коде — функция `make(T type)`),
позволяют объявлять (описывать) универсальные методы, т.е. в качестве параметров и возвращаемых значений указывать
не один тип, а их наборы.

Появились новые ключевые слова:

* `any` — аналог `interface{}`, можно использовать в любом места
(`func do(v any) any`, `var v any`, `type foo interface { Do() any }`);
* `comparable` — интерфейс, определяет типы, которые могут быть сравнены с помощью `==` и `!=`
(переменные такого типа создать нельзя — `var j comparable` вызовет **ошибку**).

И появилась возможность определять интерфейсы,
которые можно будет использовать в параметризованных функциях и типах
(переменные такого типа создать нельзя — `var j Int` вызовет **ошибку**):

        type Int interface {
          int | int32 | int64
        }

Если добавить `~` перед типами, то интерфейсу будут соответствовать и производные типы, например, `myInt`:

        type Int interface {
          ~int | ~int32 | ~int64
        }

        type myInt int 

Разработчики создали готовый набор интерфейсов (пакет `constraints`), удобно использовать.

**Параметризованные функции**:

Пример функции, возвращает максимум из двух переданных значений, тип может быть любым:

        import "constraints"

        func Max[T constraints.Ordered](a T, b T) T {
          if a > b {
            return a
          }

          return b
        }

Ограничения на используемые типы описываются в квадратных скобках.

В качестве ограничения для типов можно использовать любой интерфейс и особые интерфейсы (см. выше).

**Параметризованные типы**

        import "reflect"

        type myMap[K comparable, V any] map[K]V

        func main() {
          m := myMap[int, string]{5: "foo"}

            println(m[5])              // foo
            println(reflect.TypeOf(m)) // main.myMap[int,string]
        }

#### Garbage Collection (`GC`)

Процесс освобождения места в памяти, которая больше не используется.
`stack` освобождается быстро и просто (условно-самостоятельно), а вот с `heap` имеются некоторые сложности.

В основе работы `GC` в Go лежит:

* "**Трехцветный алгоритм пометки и очистки**" (выполняется параллельно с основной программой) — все данные в `heap`
представляются в виде связанного графа, каждая вершина которого (каждый объект, данные) может быть помечена как
"белая", "серая", или "чёрная"; данный граф обходится в несколько проходов, 
все вершины размечаются своими цветами, и "белые" (мусорные) объекты могут быть удалены 
("чёрные" — точно нельзя удалять; "серые" — под вопросом, пока не трогать);
* **Write Barrier**, следящий за тем, чтоб "черные" объекты не указывали на "белые",
и "останавливать мир" (Stop The World, STW) для включения или отключения **Write Barrier**.

`GC` можно вызвать вручную — `runtime.GC()`, но пользоваться с осторожностью
(риск блокировки вызывающей стороны или всего приложения целиком).

**По умолчанию**, `GC` запускается самостоятельно,
когда размер `heap` становится в **2 раза больше** 
(за это отвечает `Pacer`; данный коэффициент можно регулировать при сборке с помощью env `GOGC`).

Полный цикл работы `GC`:

* **Sweep termination** — фаза завершения очистки:
    * **Stop** the World;
    * Ожидаем пока все горутины достигнут **safe-point**; 
    * Завершаем очистку ресурсов;
* **Mark phase** — фаза разметки (выполняется конкурентно с основной программой, выделяется на неё **~25% CPU**):
    * Включаем **Write Barrier**;
    * **Start** the World;
    * Запускаем сканирование глобальных переменных и стеков;
    * При сканировании работа горутины приостанавливается (но не происходит полная остановка всей программы);
    * Выполняем 3-х цветный алгоритм поиска мусора;
* **Mark termination** — фаза завершения разметки:
    * **Stop** the World (не является обязательной, но с ней проце было реализовать);
    * Дожидаемся завершения обработки последних задач из очереди;
    * Очистка кэшей;
    * Завершаем разметку;
* **Sweep phase** — фаза очистки:
    * **Отключаем** Write Barrier;
    * **Start** The World;
    * Очистка ресурсов происходит в фоне.

**Недостатки**:

* Не реализован алгоритм поколений (GC Generations);
* Не реализовано уплотнение;
* Stop the World (STW), вызываемый **дважды**;
* Нет возможности тонкой настройки.

**Для оптимизации можно**:

* Уменьшить частоту вызова `GC` с помощью `GOGC`;
* Использовать балласт (выделять большое количество памяти при запуске приложения `make([]byte, 10 << 30) // 10 GiB`),
который увеличивает базовый размер `heap`, не будет выделен как мусор, помечается за `O(1)`,
выделяется в виртуальном пространстве не используя физическую память;
* Использовать `sync.Pool` (хорошо дружит с `GC`).

#### Компилятор

**Компиляция** — процесс преобразования твоего кода в машинный код. Первое понятно тебе, второе — машине.

`cmd/compile` содержит основные пакеты Go компилятора.

Процесс компиляции может быть логически разделен на **четыре фазы**:

* **Parsing** (`cmd/compile/internal/syntax`) — сорец парсится, разбивается на токены, создается синтаксическое дерево;
* **Type-checking and AST (Abstract Syntax Tree) transformations** (`cmd/compile/internal/gc`) — дерево переводится в AST,
здесь же происходит авто-типизация, проверка интерфейсов этапа компиляции, определяется мертвый код
и происходит escape-анализ;
* **Generic SSA (Static Single Assignment)** (`cmd/compile/internal/gc`, `cmd/compile/internal/ssa`) — AST переводится
в SSA (промежуточное представление более низкого уровня), упрощает реализацию оптимизаций;
так же применяются множественные оптимизации этого уровня
(тут, например, циклы `range` переписываются в обычные `for`, `copy` заменяется перемещением памяти),
удаляются ненужные проверки на `nil` и т.д.;
* **Generating machine code** (`cmd/compile/internal/ssa`, `cmd/internal/obj`) — универсальные штуки перезаписываются
на машинно-зависимые (в зависимости от архитектуры и ОС), после чего над SSA снова выполняются оптимизации,
удаляется мертвый код, распределяются регистры, размечается стековый фрейм; после, ассемблер превращает всё это добро
в машинный код и записывает объектный файл.

#### Статическая компиляция/линковка, особенности

Линковка (компоновка) - последний этап сборки. Статически слинкованный исполняемый файл не зависит от наличия других
библиотек в системе во время своей работы.

Для включения статической компиляции/линковки (при этом все внешние библиотеки, от которых зависит исполнение
кода будут встроены в итоговый бинарный файл) необходимо использовать переменную окружения при сборке `CGO_ENABLED=0` 
(т.е. `CGO_ENABLED=0 go build ...`). Полученный бинарный файл можно безбоязненно использовать, например, в docker-образе,
основанном на `scratch` (т.е. не содержащем абсолютно никаких файлов, кристально чистая файловая система).

Это накладывает ограничения и особенности, которые необходимо помнить:

* `C`-код будет недоступен, совсем (часть модулей, не критичных, из `stdlib` Go от него зависят);
* Не будет использоваться **системный** DNS-резольвер;
* Не будет работать проверка `x.509` сертификатов, которая должна работать на MacOS X.

Если итоговый бинарный файл планируется использовать в docker `scratch`, то иметь в виду:

* Для осуществления HTTP запросов по протоколу HTTPS приложением, в образ нужно будет поместить корневые
SSL/TLS сертификаты `/etc/ssl/certs`;
* Файл временной зоны (`/etc/timezone`) тоже будет необходим, чтоб корректно работать с датой/временем.

#### Директивы компилятора

Компилятор Go понимает некоторые директивы (пишутся виде комментариев, как правило, `//go:directive`),
которые влияют на процесс компиляции (оптимизации, проверок, и т.д.), но не являются частью языка.

**Некоторые** из них:

`//go:linkname`

Указывает компилятору реальное местонахождение функции или переменной.
Можно использовать для вызова приватных функций из других пакетов. 
Требует импортирования пакета `unsafe` (`import _ "unsafe"`). 

**Формат**:

        //go:linkname localname [importpath.name]

**Пример**:

        import (
            _ "strings" // for explodeString
            _ "unsafe"  // for go:linkname
        )

        //go:linkname foo main.bar
        func foo() string

        func bar() string { return "bar" }

        //go:linkname explodeString strings.explode
        func explodeString(s string, n int) []string

        func main() {
            println(foo())                    // bar
            println(explodeString("foo", -1)) // [3/3]0xc0000a00f0
        }

`//go:nosplit`

Указывается при объявлении функции, указывает на то, что вызов функции должен пропускать все обычные проверки
на переполнение стека.

`//go:norace`

Также указывается при объявлении функции, "выключает" детектор гонки (`race detector`) для неё.

`//go:noinline`

Отключает оптимизацию "инлайнига" для функции. Обычно, используется для отладки компилятора,
escape-аналитики или бенчмаркинга.

`//go:noescape`

Тоже "функциональная" директива, смысл сводится к тому, что "я доверяю этой функции, и ни один указатель,
переданный в качестве аргумента (или возвращенный) этой функции не должен быть помещен в `heap`".

`//go:build`

Директива обеспечивает условную сборку, т. е. можем "размечать" тегами файлы, т. о. компилировать только определенные
их "наборы" (тегов может быть несколько, можно использовать `!` для указания "не"). 
Часто используется для кодогенерации, указывая какой-то специфичный тег (например, `ignore` — `//go:build ignore`),
чтобы файл никогда не учавствовал в сборке итогового приложения.

**Пример**, создание 2 файлов в одной директории:

        // file: main.go
        //go:build one

        package main

        func main() { println("one!") }
<br>

        // file: main2.go
        //go:build two

        package main

        func main() { println("two!") }

Соберем с разными значениями `-tags` для `go build` или `go run`
(какой именно файл собирать не указывается, только тег):

        $ go run -tags one .
        one!

        $ go run -tags two .
        two!

`//go:generate`

Позволяет указать какие внешние команды должны вызваться при запуске `go generate`.
Можем использовать кодогенерацию, или выполнять какие-то операции, что должны предшевствовать сборке
(пример — `//go:generate go run gen.go` где `gen.go` - файл, содержащий `//go:build ignore`,
т.е. исключён из компиляции, при этом генерирует для какие-то полезные данные и/или целые `.go` файлы):

        package main

        //go:generate echo "my build process"
        func main() {
            println("hello world")
        }
<br>

        $ go generate
        my build process

`//go:embed`

Позволяет "встраивать" внешние файлы в Go приложение.
Требует импортирования пакета `embed` (`import _ "embed"`). 
Поддерживает типы `string`, `[]byte` и `embed.FS`. 

**Пример**:

        package main

        import _ "embed"

        //go:embed test.txt
        var hello string

        func main() {
            println(hello)
        }
<br>

        $ echo "hello world" > test.txt

        $ go run .
        hello world