Go работает со следующими типами:

* `Method` (метод);
* `Boolean` (логический тип);
* `Numeric` (численный);
* `String` (строковый);
* `Array` (массив);
* `Slice` (слайс);
* `Struct` (структура);
* `Pointer` (указатель);
* `Function` (функция);
* `Interface` (интерфейс);
* `Map` (хэш таблица);
* `Channel` (канал);

#### Numeric (численный):

**целочисленные**:

* `int8` - целое число от `-128` до `127`, занимает 1 байт (8 бит);
* `int16` - целое число от `-32768` до `32767`, занимает 2 байта (16 бит);
* `int32` - целое число от `-2147483648` до `2147483647`, занимает 4 байта (32 бита);
* `int64` - целое число от `–9 223 372 036 854 775 808` до `9 223 372 036 854 775 807`, занимает 8 байт (64 бита);
* `uint8` - целое число от `0` до `255`, занимает 1 байт; 
* `uint16` - целое число от `0` до `65535`, занимает 2 байта; 
* `uint32` - целое число от `0` до `4294967295`, занимает 4 байта; 
* `uint64` - целое число от `0` до `18 446 744 073 709 551 615`, занимает 8 байт; 
* `byte` - синоним `uint8`, представляет целое число от `0` до `255`, занимает 1 байт; 
* `rune` - синоним `int32`, представляет целое число от `-2147483648` до `2147483647`, занимает 4 байта; 
* `int` - целое число со знаком, в зависимости от платформы может занимать либо 4 байта, либо 8 байт,
                  т.е. соответствовать либо `int32`, либо `int64`; 
* `uint` - целое число без знака, аналогично `int`, в зависимости о платформы может занимать либо 4 байта,
                  либо 8 байт, т.е. соответствовать либо `uint32`, либо `uint64`;

**с плавающей точкой**:

* `float32` - число с плавающей точкой от 1.4 * 10<sup>-45</sup> до 3.4 * 10<sup>38</sup> (для положительных),
занимает 4 байта (32 бита);
* `float64` - число с плавающей точкой от 4.9 * 10<sup>-324</sup> до 1.8 * 10<sup>308</sup> (для положительных),
занимает 8 байт;

**комплексные**:

* `complex64` - комплексное число, где вещественная и мнимая части представляют числа `float32`;
* `complex128` - комплексное число, где вещественная и мнимая части представляют числа `float64`.
      
#### Boolean (логический тип)

Логический тип `bool`, может быть или `true` (истина), или `false` (ложь).

#### `String` (строковый)

        str := "Hello"
        str := `Multiline
        string`

Строки в GO - слайсы байт, доступные только для чтения.
Строка содержит произвольные байты, и у неё **нет** ёмкости (`cap`). 
При преобразовании слайса байт в строку (`str := string(slice)`) или обратно (`slice := []byte(str)`)
— происходит копирование массива (со всеми следствиями).

Создание подстрок работает очень эффективно, поскольку строка предназначена только для чтения,
исходная строка и строка, полученная в результате операции среза, 
могут безопасно совместно использовать один и тот же массив:

        var (
            str = "hello world"
            sub = str[0:5]
            usr = "/usr/kot"[5:]
        )

        print(sub, " ", usr) // hello kot

Есть возможность сделать строку из слайса байт без копирования - пример **из стандартной библиотеки**: 
`(*strings.Builder).String()`, но изменение исходного слайса байт изменит и строку.
Go использует тип `rune` (синоним `int32`) для представления `Unicode`. 
Конструкция `for ... range` итерирует строку **посимвольно**, а не побайтово:

        var str = "привет"

        println(str, len(str)) // привет 12

        for i, c := range str {
            println(i, c, string(c))
        }

        // 0 1087 п
        // 2 1088 р
        // 4 1080 и
        // 6 1074 в
        // 8 1077 е
        // 10 1090 т

Для кодирования **каждого** символа **кириллицы** используется по **2 байта**.

Когда есть необходимость **часто** выполнять **конкатенацию**, например,
можно использовать **слайс байт** или `strings.Builder`:

        import "strings"

        func main() { // происходит только 1 аллокация при вызове `Grow()`
            var str strings.Builder

            str.Grow(12) // сразу выделяем память

            str.WriteString("hello")
            str.WriteRune(' ')
            str.WriteString("мир")

            println(str.String()) // hello мир
        }

Для подсчета длины строки, например, для какой-нибудь валидации, 
если считать по количеству байт, и строка содержит не только `ASCII` символы
— то **количество байт** и **фактическое количество символов** будут **расходиться**:

        const str = "hello мир!"
        println(len(str), utf8.RuneCountInString(str)) // 13 10

Для кодирования символов `м`, `и` и `р` используются **2 байта** вместо одного. 
Поэтому `len == 13`, а **фактически** в строке лишь **10** символов 
(пакет `utf8`, например, нам в помощь).

Если переменной **не присвоено** значение, 
то она имеет значение **по умолчанию**, 
которое определено для ее типа: 
для числовых типов - `0`, для логического типа - `false`, для строк - `""` (пустая строка).

#### Array (массив)

        var numbers [5]int
        numbers := [...]int{0, 0, 0, 0, 0}

Доступ `O(1)`, поиск, вставка и стирание `O(n)`.

Структура данных **фиксированной** ёмкости (объявляется в момент создания, после нельзя изменить - его длина -
часть его типа)
с упорядоченным набором элементов одного типа,
расположенных в памяти последовательно.
Доступ к элементам по индексу, начинается с `0`.

Выделение памяти происходит сразу в момент объявления, по умолчанию инициализируется в соответствии с нулевым значением
типа (`false` для `bool`, `ноль` для `int`, `nil` для интерфейсов и т.д.).
В качестве размера можно использовать **константы**
(компилятор должен знать это значение на этапе компиляции,
т.е. что-то типа - `var a [getSize()]int` или `i := 3; var a [i]int ` **недопустимо**):

    const mySize uint8 = 8
    type myArray [mySize]byte
    var constSized = [...]int{1, 2, 3} // размер сам посчитается исходя из кол-ва эл-ов

Массивы с элементами **одного** типа, но с **разными** размерами являются **разными типами**.

Массивы не обязательно инициализировать явно.

Нулевой массив — готовый к использованию массив, элементы которого являются нулями:

    var a [4]int // [0 0 0 0]
    a[0] = 1  // [1 0 0 0]
    i := a[0] // i == 1

`[4]int` в памяти — четыре целых значения, расположенных последовательно.

В Go массивы передаются **по значению**, т.е. передавая массив в какую-либо функцию она получает **копию** массива
(для передачи его указателя нужно явно это указывать, т.е. `foo(&a)`).

* создание (указать имя, длину, тип значений):

  `var arr [3]int`

* прямая инициализация:

  `var arr = [3]int{1, 2, 3}`

* без `var`:

  `arr := [3]int{1, 2, 3}`

Обход через `for`:

    for i := 0; i < len(arr); i++ {
        fmt.Println(arr[i])
    }

Обход через `range`:

    for index, value := range arr {
        fmt.Printf("Индекс: %d, Значение: %d\n", index, value)
    }

Выход за границы массива (доступ к индексу за пределами длины) выдаст **ошибку времени выполнения**.

Всегда проверять находится ли индекс в допустимом диапазоне массива перед доступом к элементам
через сравнение индекса и длины массива:

    var arr [5]int
    index := 10 
    if index < len(arr) {
        fmt.Println(arr[index])
    } else {
        fmt.Println("Индекс выходит за границы массива.")
    }

#### Slice (слайс)

        slice := []int{2, 3, 4}
        slice := []byte("Hello")

Своего рода версия массива, но с вариативным размером
(структура данных, которая строится поверх массива и предоставляет доступ к элементами базового массива):

    type slice struct {
    array unsafe.Pointer // указатель на массив
    len   int            // длина (length)
    cap   int            // вместимость (capacity)
    }

Может менять свой размер и динамически аллоцировать память.
Для аллокации слайса можно воспользоваться одной из команд:

    var (
    a = []int{}            // []              len=0 cap=0
    b = []int{1, 2}        // [1 2]           len=2 cap=2
    c = []int{5: 123}      // [0 0 0 0 0 123] len=6 cap=6
    d = make([]int, 5, 10) // [0 0 0 0 0]     len=5 cap=10
    )

В случае (`d`) рантайм Go создаст массив из 10 элементов
(выделит память и заполнит их нулями), но доступны сразу будут только 5,
и установит значения `len` в 5, а `cap` в 10.
`Cap` - ёмкость, помогает зарезервировать место в памяти на будущее,
чтобы избежать лишних операций выделения памяти при росте слайса
(ключевой параметр для аллокации памяти, влияет на производительность вставки в слайс).
При добавлении новых элементов в слайс новый массив для него не будет создаваться до тех пор,
пока `cap` меньше `len`.

Слайсы передаются "по значению"
(фактически будет передан указатель на массив со своими `len` и `cap`).
Для защиты слайса от изменений следует передавать его копию:

    var (
    a = []int{1, 2, 0, 0, 1}
    b = make([]int, len(a))
    )

    copy(b, a)

    fmt.Println(a, b) // [1 2 0 0 1] [1 2 0 0 1]

"Под капотом" у слайса лежит указатель на массив — при изменении значений слайса они будут изменяться везде,
где слайс используется (будь то присвоение в переменную, передача в функцию и т.д.) до момента,
пока размер слайса не будет переполнен и не будет выделен новый массив для его значений
(т.е. в момент изменения (увеличения) `cap` слайса происходит копирование данных массива):

    var (
    one = []int{1, 2} // [1 2]
    two = one         // [1 2]
    )

    two[0] = 123

    fmt.Println(one, two) // [123 2] [123 2]

    one = append(one, 666)

    fmt.Println(one, two) // [123 2 666] [123 2]

При **уменьшении** `cap` копирования данных массива **не происходит**:

    a := []int{1, 2, 3, 4, 5}
	b := a[0:3:3]
	a[0] = 10
	fmt.Println(a, b, cap(a), cap(b)) // [10 2 3 4 5] [10 2 3] 5 3

#### `append` в слайсе

`append()` добавляет элементы в слайс и возвращает новый.
Но "под капотом" делаются сложные манипуляции,
чтобы выделять память только при необходимости и делать это эффективно.

Сперва `append` сравнивает значения `len` и `cap` у слайса.
Если `len` меньше, чем `cap`, то значение `len` увеличивается,
а само добавляемое значение помещается в конец слайса.
В противном случае происходит выделение памяти под новый массив для элементов слайса,
в него копируются значения из старого, и значение помещается уже в новый массив.

    var (
    one = make([]int, 4) // [0 0 0 0]
    two = one[1:3]       // [0 0]
    )

    one[2] = 11

    fmt.Println(one, two)           // [0 0 11 0] [0 11]
    fmt.Printf("%p %p\n", one, two) // 0xc0000161c0 0xc0000161c8

    one = append(one, 1)

    fmt.Printf("%p %p\n", one, two) // 0xc00001c1c0 0xc0000161c8

    one[2] = 22

    fmt.Println(one, two)           // [0 0 22 0 1] [0 11]
    fmt.Printf("%p %p\n", one, two) // 0xc00001c1c0 0xc0000161c8

Если на основании слайса `one` выделить подслайс `two`, а затем увеличить слайс `one`
(и его вместимость будет превышена) — то `one` и `two` будут уже ссылаться на **разные** участки памяти.

При  увеличении размера слайса (метод `growslice`) **до 1024** элементов, размер памяти (`cap`) увеличивается **вдвое**
(вне зависимости от запрашиваемой `cap`).

При размере слайса **более 1024** элементов, `cap` увеличивается с коеффициентом `1.25`.

#### Сортировка массива структур по алфавиту по полю `Name`

Преобразовать массив в слайс и использовать функцию `sort.SliceStable`:

    package main

    import (
    "fmt"
    "sort"
    )

    func main() {
        var arr = [...]struct{ Name string }{{Name: "b"}, {Name: "c"}, {Name: "a"}} // анонимная структура с нужным полем

        fmt.Println(arr) // [{b} {c} {a}]

        sort.SliceStable(arr[:], func(i, j int) bool { return arr[i].Name < arr[j].Name }) // из массива сделан слайс

        fmt.Println(arr) // [{a} {b} {c}]
    }

При создании слайса из массива "под капотом" у слайса начинает лежать исходный массив,
и функции из пакета `sort` становятся доступны над ним.
Т.е. изменяя порядок элементов в слайсе функцией `sort.SliceStable` меняем их в исходном массиве.

#### Мини задача 1

У нас есть 2 функции — одна делает `append()` чего-то в слайс,
а другая просто сортирует слайс, используя пакет `sort`.
Модифицируют ли слайс первая и (или) вторая функции?

**Ответ**: `append()` **не модифицирует**, а возвращает **новый** слайс,
а `sort` **модифицирует** порядок элементов, если он изначально был не отсортирован.

#### Мини задача 2

Что выведет следующая программа?

    package main

    import "fmt"

    func main() {
      a := [5]int{1, 2, 3, 4, 5}
      t := a[3:4:4]

      fmt.Println(t[0])
    }

**Ответ**: `4`

**Объяснение**: Такой синтаксис (появился в Go 1.2) позволяет задать `cap` для полученного под-слайса,
который будет равен "последний элемент минус первый элемент из выражения в квадратных скобках",
т.е. из примера выше он будет равен 1
(т.к. от четырёх, т.е. третьего сегмента вычитаем первый, т.е. тройку).
Если бы выражение имело вид `a[3:4:5]`, то `cap` была бы равна `2` (5 — 3 = 2).
Но при этом на сами данные он не влияет.

#### **zero value** у слайса, возможные операции над ним

Zero value у слайса всегда `nil`, а `len` и `cap` равны `0`,
так как "под ним" нет инициализированного массива:

    var a []int

    println(a == nil, len(a), cap(a)) // true 0 0
    a = append(a, 1)
    println(a == nil, len(a), cap(a)) // false 1 1

Несмотря на то, что `a == nil` (слайс "не инициализирован"),
с этим слайсом возможна операция `append` — в этом случае Go самостоятельно создаёт нижележащий массив
и всё работает так, как и ожидается.
Для полной очистки слайса рекомендуется его присваивать к `nil`.

**Не делая** `make` для слайса — **не получится** сделать **пре-аллокацию**,
что часто сказывается на производительности.


#### Pointer (указатель)

        func main () {
            b := *getPointer()
            fmt.Println("Value is", b)
        }

        func getPointer () (myPointer *int) {
            a := 234
            return &a
        }

        a := new(int)
        *a = 234

#### Map (хэш таблица)

**Неупорядоченная** коллекция пар вида ключ-значение:

        type myMap map[string]int

К элементам `Map` можно обратиться с помощью скобок:

        var m = make(map[string]int) // инициализация
        m["one"] = 1 // запись в map
        fmt.Println(m["one"], m["two"]) // 1 0

Желательно выделять память **заранее** (передавать вторым аргументом функции `make`),
если известно количество элементов — избежим **эвакуаций**.
В случае с `m["two"]` вернулся `0`, т. к. это нулевое значение для типа `int`. 

Для проверки существования ключа использовать конструкцию `multiple assignment`
(доступ к элементу `Map` может вернуть два значения вместо одного):

        var m = map[string]int{"one": 1}

        v1, ok1 := m["one"] // чтение
        v2, ok2 := m["two"]

        fmt.Println(v1, ok1) // 1 true
        fmt.Println(v2, ok2) // 0 false

        for k, v := range m { // итерация всех эл-ов map
            fmt.Println(k, v)
        }

        delete(m, "one") // удаление

        v1, ok1 = m["one"]

        fmt.Println(v1, ok1) // 0 false

`Map` в Go — указатель на структуру `hmap`:

        type hmap struct {
        // Note: the format of the hmap is also encoded in cmd/compile/internal/reflectdata/reflect.go.
        // Make sure this stays in sync with the compiler's definition.
        count     int // # live cells == size of map.  Must be first (used by len() builtin)
        flags     uint8
        B         uint8  // log_2 of # of buckets (can hold up to loadFactor * 2^B items)
        noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details
        hash0     uint32 // hash seed

        buckets    unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.
        oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing
        nevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)

        extra *mapextra // optional fields
    }

Так же структура `hmap` содержит:

* Количество элементов;
* Количество `bucket` (в виде логарифма, для ускорения вычислений);
* `Seed` для рандомизации хэшей (своего рода защита от ddos попыток подобрать ключи так, что будут сплошные коллизии);
* Служебные поля и указатель на `buckets`, где хранятся значения.

<img src="https://habrastorage.org/r/w1560/webt/aj/yg/nf/ajygnfp_745tid9futbqteysivc.png" title="map" width="1000" alt="map"/>

Есть `header hmap`, указатель на который и есть `map` в Go 
(именно он создается при объявлении с помощью `var`, но не инициализируется,
из-за чего падает программа при попытке вставки). 
Поле `buckets` — хранилище пар ключ-значение, таких `bucket` несколько, в каждом лежит **8 пар**.
Сначала в `bucket` лежат слоты для дополнительных битов хэшей (`e0..e7` `e` — `extra hash bits`).
Далее лежат ключи и значения, как сначала: список всех ключей, потом список всех значений.

По хэш функции определяется в какой `bucket` кладется значение, внутри каждого `bucket` может лежать **до 8 коллизий**,
в конце каждого `bucket` есть указатель на дополнительное, если вдруг предыдущее переполнилось.

**Рост** `map`

В исходниках Go - `Maximum average load of a bucket that triggers growth is 6.5`,
т. е., если в каждом `bucket` в среднем **более 6,5 элементов**,
происходит **увеличение** массива `buckets`.
При этом выделяется массив в **2 раза больше**, а старые данные копируются в него маленькими порциями каждые вставку
или удаление, чтобы не создавать очень крупные задержки. 
Поэтому все операции будут чуть медленнее в процессе эвакуации данных
(при поиске тоже, потому что ищем в двух местах). 
После успешной эвакуации начинают использоваться новые данные.

Из-за эвакуации данных **нельзя** взять адрес `Map`.
Представим, что взяли адрес значения,
а потом `Map` выросла, выделилась новая память, данные эвакуировались, 
старые удалились, указатель стал неправильным, поэтому такие операции **запрещены**.

**Поиск в** `Map`

Проходимся по цепочкам `bucket`, переходя в следующую, если в этой не нашли. 
Поиск в `bucket` начинается с быстрого сравнения дополнительного хэша, 
для которого используется **8 бит** 
(`e0...e7` в начале каждого — "мини" хэш пары для быстрого сравнения). 
Если не совпало, идем дальше, если совпало, то проверяем тщательнее — определяем где лежит в памяти ключ,
подозреваемый как искомый, сравниваем равен ли он тому, что запросили. 
Если равен, определяем положение значения в памяти и возвращаем.

Когда имя хешируется, некоторые данные теряются, т. к. хеш, как правило, короче исходной строки. 
В любой реализации хеш таблицы неизбежны коллизии,
когда по двум ключам получаются одинаковые хеши. 
Как следствие, поиск может быть дороже чем `O(1)`
(возможно, связано с кешем процессора и коллизиями коротких хэшей), 
иногда выгоднее использовать бинарный поиск по слайсу данных, нежели поиск в `Map`.

У `Map` есть `len`, но нет `cap`. Есть `overflow`, который указывает "куда-то", когда `Map` переполняется,
поэтому нет `capacity`.

В `Map` **можно** использовать **для ключа** любые сравнимые (comparable) типы,
т.е. булевы, числовые, строковые, указатели, канальные и интерфейсные типы,
а также структуры или массивы, содержащие только эти типы.
Слайсы, хэш таблицы и функции использовать **нельзя**, т. к. эти типы **не сравнить** с помощью оператора `==` или `!=`.

**Структура может быть ключом до тех пор,
пока мы в поля структуры не поместим какой-либо слайс,
хэш таблицу или любой другой non-comparable тип данных (например, функцию)**.

Если **не делать** `make` или `short assign`, при **записи** в `Map` будет **паника**.

Из не инициализированной `Map` можно читать любые ключи (получим zero value), получить `len()`, сравнить с `nil`.

`Map` **не потокобезопасна** (параллельный доступ), потокобезопасная - `sync.Map`.
Для чтения `Map` безопасна — 1000 горутин могут читать из `Map` без опасений,
но параллельно в неё ещё и писать — **нет**.
Для обеспечения безопасности вокруг `Map` обычно строится структура вида:

        type ProtectedIntMap struct {
        mx sync.RWMutex
        m  map[string]int
        }

        func (m *ProtectedIntMap) Load(key string) (val int, ok bool) {
            m.mx.RLock()
            val, ok = m.m[key]
            m.mx.RUnlock()

            return
        }

        func (m *ProtectedIntMap) Store(key string, value int) {
            m.mx.Lock()
            m.m[key] = value
            m.mx.Unlock()
        }

`synс.Map` предоставляет атомарный доступ к элементам `Map`.

Для обеспечения потоко-безопасного доступа к `Map` можно использовать `sync.RWMutex`,
но он имеет проблему производительности при работе на большом количестве ядер процессора
(в `RWMutex` при блокировке на чтение каждая горутина должна обновить поле `readerCount` — простой счётчик,
с помощью `atomic.AddInt32()`, что проиводит к сбросу кэша для этого адреса памяти для всех ядер,
и каждое ядро становится в очередь и ждёт этот сброс и вычитывание из кэша — проблема называется **cache contention**).

`sync.Map` решает совершенно конкретную проблему **cache contention** в стандартной библиотеке для таких случаев,
когда ключи в `Map` стабильны (не обновляются часто) и происходит намного больше чтений, чем записей.

Пример `sync.Map`:

        var m sync.Map

        m.Store("one", 1)        // запись
        one, ok := m.Load("one") // чтение

        fmt.Println(one, ok) // 1 true

        m.Range(func(k, v interface{}) bool { // итерация эл-ов map
            fmt.Println(k, v) // one 1

            return true
        })

        m.Delete("one") // удаление


#### Interface (интерфейс)

Инструмент для определения наборов действий и поведения.

Интерфейс — **контракт**. 

Позволяет объектам опираться на абстракции, а не фактические реализации других объектов. 
При этом для компоновки различных поведений можно группировать несколько интерфейсов. 

В общем смысле — набор методов, представляющих стандартное поведение для различных типов данных.

**Duck-typing в Go**

Если структура содержит в себе все методы, что объявлены в интерфейсе, и их сигнатуры совпадают — 
она автоматически удовлетворяет интерфейс.

Такой подход позволяет полиморфно (полиморфизм — способность функции обрабатывать данные разных типов)
работать с объектами, которые не связаны в иерархии наследования. 
Достаточно, чтобы все эти объекты поддерживали необходимый набор методов.

Интерфейсный тип в исходниках Go:

    type iface struct {
    tab  *itab
    data unsafe.Pointer
    }

`tab` — указатель на `itable` — структуру, которая хранит некоторые метаданные о типе и список методов,
используемых для удовлетворения интерфейса, а `data` указывает на реальную область памяти,
в которой лежат данные изначального объекта (статическим типом).

Компилятор генерирует метаданные для каждого статического типа, в которых, помимо прочего, хранится список методов,
реализованных для данного типа.
Аналогично генерируются метаданные со списком методов для каждого интерфейса.

Во время исполнения программы, **runtime Go** может вычислить `itable` на лету (`late binding`)
для каждой конкретной пары, этот `itable` кешируется, поэтому просчёт происходит только один раз.

Go ловит несоответствия типов на этапе компиляции, но кастинг к интерфейсу — во время исполнения.

Переменная интерфейсного типа может принимать `nil`, но т. к. объект интерфейса в Go содержит два поля:
`tab` и `data` — по правилам Go, интерфейс может быть равен `nil` только если оба этих поля не определены:

    var (
    builder  *strings.Builder
    stringer fmt.Stringer
    )

    fmt.Println(builder, stringer) // nil nil
    fmt.Println(stringer == nil)   // true
    fmt.Println(builder == nil)    // true

    stringer = builder

    fmt.Println(builder, stringer) // nil nil
    fmt.Println(stringer == nil)   // false (!!!)
    fmt.Println(builder == nil)    // true

**Пустому** `interface{}` удовлетворяет вообще любой тип.

Пустой интерфейс ничего не означает, никакой абстракции. 

Желательно использовать пустые интерфейсы в самых крайних случаях.

По умолчанию описывать интерфейсы следует на **принимающей** стороне — 
код будет меньше зависеть от какого-то другого кода/пакета/реализации.

Если в каком-то месте требуется "что-то, что умеет себя закрывать", или имеет метод `Close() error`,
или удовлетворят интерфейсу:

    type something interface {
    Close() error
    }

то интерфейс должен быть описан на **принимающей** стороне, так принимающая сторона не будет ничего знать о том,
что именно в неё может "прилететь", но точно знает поведение этого "чего-то".

Т. о. реализуется **инверсия зависимости**, и код становится проще переиспользовать/тестировать.

#### Function (функция)

**По умолчанию** при передаче в функцию всегда используется **копирование**, т.е. передача **по значению**.

Для передачи по **указателю** необходимо это **явно** указывать:

        func main() {
            var i = 5

            byValue(i)    // 5
        byPointer(&i) // 5
        }

        func byValue(i int)    { println(i) }  // передача по значению (копии переменной)
        func byPointer(i *int) { println(*i) } // передача по указателю

**Замыкания** — функции, которые можно создавать в рантайме и им будет доступно текущее окружение,
в рамках которого они были созданы.

Функции, у которых есть имя — **именованные** функции.

Функции, которые могут быть созданы без указания имени — **анонимные** функции.

    func main() {
        var text = "some string"

        var ourFunc = func() { // именованное замыкание
            println(text)
        }

        ourFunc() // some string
        getFunc()() // another string
    }

    func getFunc() func() {
        return func() { // анонимное
            println("another string")
        }
    }

Замыкания сохраняют состояние, означает, что состояние переменных содержится в замыкании в момент декларации. 

Очевидная ловушка — создание замыканий в цикле:

    var funcs = make([]func(), 0, 5)

    for i := 0; i < 5; i++ {
        funcs = append(funcs, func() { println("counter =", i) })

        // исправляется так:
        // var value = i
        // funcs = append(funcs, func() { println("counter =", value) })
    }

    for _, f := range funcs {
        f()
    }

    // counter = 5 (так все 5 раз)